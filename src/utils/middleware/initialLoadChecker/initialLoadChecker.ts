import { GetServerSidePropsContext, GetServerSidePropsResult } from "next";
import { logAndReturnError } from "./ErrorModule";
import {
  createUser,
  storeTokensInDatabase,
} from "./database/UserDatabaseModule";
import {
  createDirectusUser,
  loginDirectusUser,
} from "./directus/DirectusUserModule";
import { exchangeTokenWithShopify } from "./shopify/ShopifyModule";
import { prisma } from "../../../lib/prisma";
import { createCompany, fetchCompanies } from "@/services/company/company";
import shopify from "../../shopify/shopifyClient";
import { RequestedTokenType } from "@shopify/shopify-api";
import { updateUserData, fetchUserData } from "@/services/auth/auth";

interface User {
  id: number;
  email: string;
  password: string;
  shopDomain: string | null;
}



interface Context extends GetServerSidePropsContext {
  query: {
    shop?: string;
    id_token?: string;
    [key: string]: string | string[] | undefined;
  };
}

const normalizeShopDomain = (shopDomain: string): string =>
  shopDomain.replace(/\.myshopify\.com$/, "");

const validateShopParameter = (shop?: string): boolean =>
  Boolean(shop && shop.endsWith(".myshopify.com"));

const findExistingUser = async (
  email: string,
  shopDomain: string
): Promise<User | null> =>
  await prisma.user.findFirst({
    where: { email, shopDomain },
  });

const findExistingUserByShop = async (
  shopDomain: string
): Promise<User | null> =>
  await prisma.user.findFirst({
    where: { shopDomain },
  });

const fetchExistingTokens = async (userId: number) => {
  return await prisma.token.findFirst({
    where: { userId },
  });
};

const getValidTokens = async (
  userId: number,
  email: string,
  password: string
) => {
  const tokenRecord = await fetchExistingTokens(userId);
  const currentTime = new Date();

  if (
    tokenRecord &&
    tokenRecord.expiresAt > currentTime &&
    tokenRecord.sessionAccessTokenExpiresAt > currentTime && tokenRecord.accessToken && tokenRecord.refreshToken
  ) {
    console.log("Using existing valid tokens.");
    return {
      accessToken: tokenRecord.accessToken,
      refreshToken: tokenRecord.refreshToken,
      sessionAccessTokenExpiresAt: null,
    };
  } else {
    console.log("Tokens are invalid or expired, refreshing tokens.");

    // Fetch the user record from the database to retrieve the latest password
    const userRecord = await prisma.user.findUnique({
      where: { id: userId },
      select: { password: true }, // Only select the password field
    });

    if (!userRecord || !userRecord.password) {
      throw new Error("Failed to retrieve user password from the database.");
    }

    console.log("Retrieved password from database:", userRecord.password);

    // Use the retrieved password for the token refresh process
    return await handleTokenRefresh(email, userRecord.password, userId);
  }
};

const handleTokenRefresh = async (
  email: string,
  password: string,
  userId: number
) => {
  console.log("email to use login directus", email);

  const directusTokens = await loginDirectusUser(email, password);
  const accessToken = directusTokens.accessToken;
  const refreshToken = directusTokens.refreshToken;
  console.log("directusTokens", directusTokens);


  const sessionAccessTokenExpiresAt = new Date(Date.now() + 1.5 * 3600 * 1000);
  await storeTokensInDatabase(
    userId,
    accessToken,
    refreshToken,
    new Date(Date.now() + 5 * 24 * 3600 * 1000),
    sessionAccessTokenExpiresAt
  );

  return { accessToken, refreshToken, sessionAccessTokenExpiresAt };
};

const ensureCompanyExists = async (shop: string, accessToken: string) => {
  const existingCompanies = await fetchCompanies(accessToken);
  console.log("Existing companies:", existingCompanies);

  // Find the existing company that matches the domain (shop)
  const existingCompany = existingCompanies.find(
    (company) => company.domain === shop
  );

  if (existingCompany) {
    console.log(`Company already exists: ${shop}`);
    return existingCompany.UUID; // Return the UUID of the existing company
  } else {
    // Create a new company if it doesn't exist
    const newCompany = await createCompany(
      {
        name: shop,
        domain: shop,
        logo: null,
        date_created: new Date(),
        UUID: "", // Leave this to be generated by the backend
      },
      accessToken
    );
    console.log(`Company created: ${shop}`);
    return newCompany.UUID; // Return the UUID of the newly created company
  }
};




const ensureShopifyTokenExists = async (
  accessToken: string,
  shopifyOfflineToken: string
) => {
  // Fetch the user data based on the access token
  const userData = await fetchUserData(accessToken);
  const existingShopifyToken = userData?.shopifyOfflineToken;

  const TOKEN = process.env.TOKEN as string;

  if (!existingShopifyToken) {
    // If the Shopify token does not exist, update the user data
    await updateUserData(
      TOKEN, // Passing the access token as the Bearer token for the update
      userData.id, // Assuming userData has an ID property for the Directus user ID
      { ShopifyToken: shopifyOfflineToken } // Object containing the new Shopify token to be updated
    );
    console.log(`Shopify Token created for user ID: ${userData}`);
  } else {
    console.log(`Shopify Token already exists for user ID: ${userData}`);
  }
};

const processExistingUser = async (
  existingUser: User,
  shop: string, // The actual shop string
  normalizedShopDomain: string // The normalized version of the shop domain
) => {
  // Ensure we are using the correct shop identifier (choose shop or normalizedShopDomain)

  console.log("shop", shop);
  console.log("normalizedShopDomain", normalizedShopDomain);
  const shopDomain = shop; // Use normalizedShopDomain if available, fallback to shop

  // Find the user by shopDomain and get the email
  const userFromDb = await prisma.user.findFirst({
    where: { shopDomain }, // This will use the correct shopDomain
    select: { email: true }, // Ensure you select the email field
  });

  // Check if userFromDb is found and has an email
  if (!userFromDb || !userFromDb.email) {
    throw new Error("User not found or email is missing");
  }

  const email = userFromDb.email; // Extract the email

  console.log("Existing user found with email:", email);

  // Pass the email along with the other necessary fields
  return await getValidTokens(
    existingUser.id,
    email, // Use the retrieved email from the database
    existingUser.password
  );
};

const processNewUser = async (
  ownerEmail: string,
  ownerFirstName: string,
  ownerLastName: string,
  shop: string
): Promise<{ user: User }> => {
  const emailToUse = generateUniqueEmail(ownerEmail, shop);

  // Check if the user already exists
  let existingUser = await findExistingUser(emailToUse, shop);

  if (existingUser) {
    console.log("User already exists. Using existing user.");
    return {
      user: existingUser,
    };
  }

  const newUser = await createUser(
    emailToUse,
    ownerFirstName,
    ownerLastName,
    shop
  );

  if (!newUser) {
    throw new Error("Failed to create the user.");
  }

  // Log the password before creating the user in Directus
  console.log(`Creating Directus user with the following details:
    Email: ${emailToUse}
    First Name: ${ownerFirstName}
    Last Name: ${ownerLastName}
    Hashed Password: ${newUser.hashedPassword}`);

  // Create the user in Directus with the hashed password
  await createDirectusUser(
    emailToUse,
    ownerFirstName,
    ownerLastName,
    newUser.hashedPassword
  );

  // Return the newly created user object
  return {
    user: {
      ...newUser,
      password: "", // Add the password property
    },
  };
};

const generateUniqueEmail = (email: string, shop: string): string => {
  const [localPart, domainPart] = email.split("@");
  return `${localPart}+${shop}@${domainPart}`;
};

const obtainShopifyOfflineToken = async (idToken: string, shop: string) => {
  const { session: offlineSession } = await shopify.auth.tokenExchange({
    sessionToken: idToken,
    shop,
    requestedTokenType: RequestedTokenType.OfflineAccessToken,
  });

  console.log("New offline session obtained:", offlineSession);

  return offlineSession.accessToken as string;
};



const initialLoadChecker = async (
  context: Context
): Promise<GetServerSidePropsResult<{ [key: string]: any }>> => {
  let accessToken: string | null = null;
  let refreshToken: string | null = null;
  let sessionAccessTokenExpiresAt: Date | null = null;
  let user: User | null = null;

  try {
    const shop = context.query.shop as string;
    const idToken = context.query.id_token as string;

    if (!validateShopParameter(shop)) {
      return logAndReturnError("Invalid shop parameter");
    }

    if (!idToken) {
      return {
        redirect: {
          destination: `/brand/dashboard?shop=${shop}`,
          permanent: false,
        },
      };
    }

    const onlineSession = await exchangeTokenWithShopify(shop, idToken);
    const ownerEmail = onlineSession.onlineAccessInfo?.associated_user.email;

    if (!ownerEmail) {
      throw new Error("Owner email is required but not found.");
    }

    const ownerFirstName =
      onlineSession.onlineAccessInfo?.associated_user.first_name ?? "";
    const ownerLastName =
      onlineSession.onlineAccessInfo?.associated_user.last_name ?? "";

    const normalizedShopDomain = normalizeShopDomain(shop);

    console.log("normalizedShopDomain:", shop);
    user = await findExistingUserByShop(shop);

    console.log("User found by shop:", user);

    console.log(
      "User already exists with email:",
      user?.email,
      " for shop domain: ",
      shop,
      " . No need to create a new user."
    );
    console.log("User ID:", user?.id);

    if (user && user.shopDomain === shop) {
      // Process existing user without attempting to refetch unnecessarily
      ({ accessToken, refreshToken, sessionAccessTokenExpiresAt } =
        await processExistingUser(user, shop, normalizedShopDomain));
    } else {
      const newUserResult = await processNewUser(
        ownerEmail,
        ownerFirstName,
        ownerLastName,
        shop
      );

      user = newUserResult.user;

      ({ accessToken, refreshToken, sessionAccessTokenExpiresAt } =
        await processExistingUser(user, shop, normalizedShopDomain));
    }

    console.log("accestoken", accessToken);


    const shopifyOfflineToken = await obtainShopifyOfflineToken(idToken, shop);


    console.log("shopifyOfflineToken", shopifyOfflineToken);

    // Ensure the company exists and capture the UUID
    const companyUUID = await ensureCompanyExists(shop, accessToken);
    console.log("Company UUID:", companyUUID);



    const generateUpdatedLiquidContent = (companyUUID: string): string => {
      return `
  <!-- Referrd Campaign Script -->
  <script defer type="text/javascript">
  (function() {
      // Utility functions
      function getCookie(name) {
          const value = \`; \${document.cookie}\`;
          const parts = value.split(\`; \${name}=\`);
          if (parts.length === 2) return parts.pop().split(';').shift();
      }

      function setCookie(name, value, days) {
          let expires = "";
          if (days) {
              const date = new Date();
              date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
              expires = "; expires=" + date.toUTCString();
          }
          document.cookie = \`\${name}=\${value || ""}\${expires}; path=/\`;
          console.log(\`Cookie set: \${name}=\${value}; Expires in \${days} days\`);
      }

      function removeCartNote(callback, retryCount = 3) {
          console.log('Attempting to remove cart note...');
          fetch('/cart/update.js', {
              method: 'POST',
              headers: {
                  'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                  note: ""
              })
          })
          .then(response => {
              if (!response.ok) {
                  return response.text().then(text => {
                      throw new Error(\`Response not OK: \${response.status} - \${response.statusText}. Response body: \${text}\`);
                  });
              }
              return response.json();
          })
          .then(data => {
              if (data && data.note === "") {
                  console.log('Cart note removed successfully:', data);
                  if (callback) {
                      setTimeout(() => callback(true), 500); // Delay before callback
                  }
              } else {
                  console.error('Failed to verify cart note removal:', data);
                  if (retryCount > 0) {
                      console.log(\`Retrying... (\${3 - retryCount + 1}/3)\`);
                      removeCartNote(callback, retryCount - 1);
                  } else {
                      if (callback) callback(false);
                  }
              }
          })
          .catch(error => {
              console.error('Error removing cart note:', error);
              if (retryCount > 0) {
                  console.log(\`Retrying... (\${3 - retryCount + 1}/3)\`);
                  removeCartNote(callback, retryCount - 1);
              } else {
                  if (callback) callback(false);
              }
          });
      }

      function addReferralUUIDToCartNote(referralUUID, callback, retryCount = 3) {
          console.log('Attempting to add Referral UUID to cart note...');

          fetch('/cart/update.js', {
              method: 'POST',
              headers: {
                  'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                  note: \`Referral UUID: \${referralUUID}\`
              })
          })
          .then(response => {
              if (!response.ok) {
                  return response.text().then(text => {
                      throw new Error(\`Response not OK: \${response.status} - \${response.statusText}. Response body: \${text}\`);
                  });
              }
              return response.json();
          })
          .then(data => {
              if (data && data.note === \`Referral UUID: \${referralUUID}\`) {
                  console.log('Cart note updated successfully:', data);
                  if (callback) {
                      setTimeout(() => callback(true), 500); // Delay before callback
                  }
              } else {
                  console.error('Failed to verify cart note update:', data);
                  if (retryCount > 0) {
                      console.log(\`Retrying... (\${3 - retryCount + 1}/3)\`);
                      addReferralUUIDToCartNote(referralUUID, callback, retryCount - 1);
                  } else {
                      if (callback) callback(false);
                  }
              }
          })
          .catch(error => {
              console.error('Error updating cart note:', error);
              if (retryCount > 0) {
                  console.log(\`Retrying... (\${3 - retryCount + 1}/3)\`);
                  addReferralUUIDToCartNote(referralUUID, callback, retryCount - 1);
              } else {
                  if (callback) callback(false);
              }
          });
      }

      function handleCheckoutButtonClick(event) {
          event.preventDefault(); // Prevent the default checkout action
          const referralUuid = localStorage.getItem('referral_uuid') || getCookie('referral_uuid');
          console.log('Checkout button clicked, attempting to add UUID to cart note...');

          if (referralUuid) {
              addReferralUUIDToCartNote(referralUuid, function(success) {
                  if (success) {
                      console.log('Referral UUID added successfully to cart note. Proceeding to checkout...');
                      const checkoutLink = event.target.closest('a, button, form');
                      if (checkoutLink) {
                          window.location.href = checkoutLink.action || checkoutLink.href;
                      }
                  } else {
                      console.error('Failed to add Referral UUID to cart note.');
                      alert('There was an issue adding the referral note. Please try again.');
                  }
              });
          } else {
              console.log('No referral UUID found. Proceeding without adding to cart note.');
              const checkoutLink = event.target.closest('a, button, form');
              if (checkoutLink) {
                  window.location.href = checkoutLink.action || checkoutLink.href;
              }
          }
      }

      function observeCheckoutButtons() {
          const observer = new MutationObserver((mutationsList) => {
              mutationsList.forEach((mutation) => {
                  if (mutation.type === 'childList') {
                      // Identify checkout-related buttons or links
                      const buttons = document.querySelectorAll('a[href*="/checkout"], button[data-testid*="Checkout"], .shopify-payment-button__button');
                      buttons.forEach(button => {
                          if (!button.dataset.uuidListenerAdded) {
                              button.dataset.uuidListenerAdded = 'true';
                              button.addEventListener('click', handleCheckoutButtonClick);
                          }
                      });
                  }
              });
          });

          // Start observing the document body for child elements being added or changed
          observer.observe(document.body, { childList: true, subtree: true });
      }

      // Function to extract the UUID based on the unconventional URL format
      function extractReferralUuidFromCustomUrl() {
          const url = window.location.href;
          if (url.includes('?referrd?-')) {
              const urlParts = url.split('?referrd?-');
              if (urlParts.length > 1) {
                  return urlParts[1].split('&')[0];  // Get UUID from '?referrd?-UUID' part
              }
          }
          return null;
      }

      // Capture and store the UUID if the URL contains '?referrd?-UUID' or '?referrd=UUID'
      const urlParams = new URLSearchParams(window.location.search);
      let referralUuid = localStorage.getItem('referral_uuid') || getCookie('referral_uuid');

      if (urlParams.has('referrd')) {
          referralUuid = urlParams.get('referrd');
          console.log(\`New UUID found in query parameter: \${referralUuid}\`);
      } else {
          // Handle unconventional ?referrd?-UUID format
          const extractedUuid = extractReferralUuidFromCustomUrl();
          if (extractedUuid) {
              referralUuid = extractedUuid;
              console.log(\`New UUID found in unconventional URL format: \${referralUuid}\`);
          }
      }

      // If referral UUID is found in the URL, localStorage, or cookies, save it
      if (referralUuid) {
          localStorage.setItem('referral_uuid', referralUuid);
          setCookie('referral_uuid', referralUuid, 365);
          console.log(\`Referral UUID saved: \${referralUuid}\`);

          // Immediately update the cart note after saving the UUID
          addReferralUUIDToCartNote(referralUuid, function(success) {
              if (success) {
                  console.log('Referral UUID added to cart note immediately after being saved.');
              } else {
                  console.error('Failed to add Referral UUID to cart note.');
              }
          });
      }

      // Check if referral UUID cookie exists and remove cart note if it doesn't
      const referralCookie = getCookie('referral_uuid');
      if (!referralCookie) {
          console.log('Referral UUID cookie not found, removing cart note...');
          removeCartNote(function(success) {
              if (success) {
                  console.log('Cart note removed successfully due to missing referral UUID cookie.');
              } else {
                  console.error('Failed to remove cart note due to missing referral UUID cookie.');
              }
          });
      }

      // Start observing the DOM for checkout buttons
      observeCheckoutButtons();

      // Ensure UUID is added before page unload (as a fallback)
      window.addEventListener('beforeunload', function(event) {
          console.log('Page is unloading, attempting to add UUID to cart note before checkout...');
          const referralUuid = localStorage.getItem('referral_uuid') || getCookie('referral_uuid');
          if (referralUuid) {
              addReferralUUIDToCartNote(referralUuid, function(success) {
                  if (success) {
                      console.log('Referral UUID added successfully to cart note before page unload.');
                  } else {
                      console.error('Failed to add Referral UUID to cart note before page unload.');
                  }
              });
          }
      });

      // Dynamically load the campaign script based on the current URL
      var fullUrl = window.location.href;
      var script = document.createElement('script');
      script.src = 'https://app.referrd.com.au/api/campaign-content/get-campaign-content?companyId=${companyUUID}&fullUrl=' + encodeURIComponent(fullUrl);
      script.defer = true;
      document.head.appendChild(script);

  })();
  </script>
  <!-- Referrd Campaign Script End -->
  `;
    };



    const fetchActiveTheme = async (shopifyOfflineToken: any, shop: any) => {
      const response = await fetch(`https://${shop}/admin/api/2023-04/themes.json`, {
        method: 'GET',
        headers: {
          'X-Shopify-Access-Token': shopifyOfflineToken,
          'Content-Type': 'application/json',
        },
      });

      const data = await response.json();
      const activeTheme = data.themes.find((theme: { role: string; }) => theme.role === 'main');

      if (!activeTheme) {
        throw new Error("Active theme not found.");
      }

      return activeTheme.id;
    };

    const fetchThemeLiquid = async (shopifyOfflineToken: any, shop: any, themeId: any) => {
      const response = await fetch(
        `https://${shop}/admin/api/2023-04/themes/${themeId}/assets.json?asset[key]=layout/theme.liquid`,
        {
          method: 'GET',
          headers: {
            'X-Shopify-Access-Token': shopifyOfflineToken,
            'Content-Type': 'application/json',
          },
        }
      );

      const data = await response.json();
      return data.asset.value; // Return the actual content of theme.liquid
    };




    const updateThemeLiquid = async (shopifyOfflineToken: string, shop: string, themeId: string, updatedLiquidContent: string) => {
      const response = await fetch(`https://${shop}/admin/api/2023-04/themes/${themeId}/assets.json`, {
        method: 'PUT',
        headers: {
          'X-Shopify-Access-Token': shopifyOfflineToken,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          asset: {
            key: 'layout/theme.liquid',
            value: updatedLiquidContent, // The new content of theme.liquid
          },
        }),
      });

      const data = await response.json();
      return data;
    };


    const ensureReferrdScriptInLiquid = async (
      shop: string,
      shopifyAccessToken: string,
      companyUUID: string
    ) => {
      try {
        // Step 1: Fetch the active theme's ID
        const themeId = await fetchActiveTheme(shopifyAccessToken, shop);

        // Step 2: Fetch the current theme.liquid content
        let currentLiquidContent = await fetchThemeLiquid(shopifyAccessToken, shop, themeId);

        // Step 3: Check if the content already includes the Referrd campaign script
        if (currentLiquidContent.includes('<!-- Referrd Campaign Script -->')) {
          console.log("Referrd campaign script already exists in theme.liquid. No update necessary.");
          return;
        }

        // Step 4: If the script doesn't exist, append it just before </body>
        const updatedLiquidContent = generateUpdatedLiquidContent(companyUUID);

        // Check if </body> tag exists, and insert the script before it
        if (currentLiquidContent.includes('</body>')) {
          currentLiquidContent = currentLiquidContent.replace('</body>', `${updatedLiquidContent}\n</body>`);
        } else {
          // If no </body> tag exists (rare case), append it to the end
          currentLiquidContent += updatedLiquidContent;
        }

        // Step 5: Update theme.liquid with the new content
        const updateResponse = await updateThemeLiquid(shopifyAccessToken, shop, themeId, currentLiquidContent);
        console.log("Updated theme.liquid with Referrd campaign script.");
        return updateResponse;
      } catch (error) {
        console.error("Error ensuring Referrd script in liquid file:", error);
        throw error;
      }
    };







    await ensureShopifyTokenExists(accessToken, shopifyOfflineToken);

    await ensureReferrdScriptInLiquid(shop, shopifyOfflineToken, companyUUID); // Pass the company UUID here



    return {
      props: {
        accessToken,
        refreshToken,
        sessionAccessTokenExpiresAt:
          sessionAccessTokenExpiresAt?.toISOString() || null,
        userId: user.id,
        shopifyOfflineToken,
      },
    };
  } catch (error) {
    const statusCode = (error as any).response?.code;
    const errorMessage =
      error instanceof Error ? error.message : "Unknown error";

    if (statusCode === 401) {
      console.error(
        `Unauthorized access when fetching data from Shopify: ${(error as any).response.statusText}`,
        error
      );
    } else {
      console.error(
        `An error occurred at initialLoadChecker: ${errorMessage}`,
        error
      );
    }

    return logAndReturnError(
      "An error occurred while processing your request.",
      error
    );
  } finally {
    await prisma.$disconnect();
  }
};

export default initialLoadChecker;
